*OOP
 - 상속 (Inheritance)
  - 기존 코드 재사용
  - 기존 코드 손대지 않고, 기능 추가

 - 캡슐화 (Encapulation)
  - 잘못된 사용을 방지하는 문법
  - 클래스를 만든 사람의 의도와 다르게 사용하는 것을 방지
  1. [접근제어] 필드 선언;
   - private int a;
  2. [접근제어] 메소드 선언;
   - private void m() { ... };

 - 다형성 (Polymarphism)
  - 프로그래밍 편의성
	
*접근 제어
 1. private - 같은 클래스의 멤버
 2. (default) - 같은 클래스의 멤버 + 같은 패키지
 3. protected - 같은 클래스의 멤버 + 같은 패키지 + 다른 패키지 + 자식 클래스
 4. public - 완전 공개

*상속 - 설계도 확장
 class Member {
	String name;
	String email;
} -> new Member() - name[] email[]

 class Student extends Member {
	String school;
	String major;
} -> new Student() - name[] email[] school[] major[]

 - Member는 super(부모) 클래스
 - Student는 sub(자식) 클래스

*다형성
 1. 다형적 변수

super 클래스 - Member [name][email][tel]
sub 클래스1 - Teacher [pay]
sub 클래스2 - Student [school][major]
sub 클래스3 - Manager [position]

Teacher t = new Teacher()
 - t[200] -- [name][email][tel] Super클래스[pay]

Student s = new Student()
 - s[300] -- [name][email][tel] Super클래스[school][major]

Manager m = new Manager()
 - m[400] -- [name][email][tel] Super클래스[position]

A 슈퍼 클래스가 현재 V1변수만 선언되어 있을 때,
A r2 레퍼런스에 r1 인스턴스[V1][V2][V4]가 치환되면
r2에서는 오직 V1변수만 사용할 수 있다.

*Overloading
 - 파라미터 타입이나 개수가 다르더라도
   같은 기능을 수행한다면, 같은 이름을 부여함으로써
   메소드 사용에 일관성을 주는 문법
 - Ex) System.out.println (오버로딩)

*Overriding
 - 상속받은 메소드를 서브 클래스 역할에 맞춰 재정의

*추상화
 - 사람, 사물, 개념을 컴퓨터에서 다룰 수 있도록,
   클래스 문법을 이용하여 데이터와 메소드로 정의하는 것










